# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uSmmgSozWe0_AeQ0fQt7Q6PEN5r7XsFi

#Upload Dataset from local system
"""

from google.colab import files
uploaded = files.upload()

"""##Load it into a DataFrame"""

import pandas as pd

df = pd.read_csv("dynamic_stall_data.csv")  # Use the actual filename you uploaded
df

df.drop(columns='No.', inplace=True)
df

cols_to_drop = [f'C_p({i})' for i in range(1, 33)]
df

"""##Compute dAoA/dt and d²AoA/dt²"""

import numpy as np

# Make sure time and AoA are floats
df['time'] = df['time'].astype(float)
df['AoA'] = df['AoA'].astype(float)


# Compute dAoA/dt (first derivative)
df['dAoA_dt'] = np.gradient(df['AoA'], df['time'])

df = df[df["time"].diff() != 0].reset_index(drop=True)
# Compute d²AoA/dt² (second derivative)
df['d2AoA_dt2'] = np.gradient(df['dAoA_dt'], df['time'])

print(df[['time', 'AoA', 'dAoA_dt', 'd2AoA_dt2']])

"""#Data preparation

##Seprating X & Y
"""

y = df[['C_l','C_d']]
y

x = df.drop(columns=['C_l','C_d'])
x

"""##Data splitting"""

from sklearn.model_selection import train_test_split

X_train, X_test, Y_train, Y_test = train_test_split(x, y, test_size=0.2, random_state=100)

X_train

X_test

"""#Model building

##LSTM
"""

import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense

# Define the Sequential model
model = Sequential()

# Add an LSTM layer with a specified number of units (e.g., 64)
# The input_shape should be (timesteps, features). Since we don't have timesteps yet, we'll just specify the number of features.
model.add(LSTM(units=64, input_shape=(X_train.shape[1], 1)))

# Add a Dense output layer with the number of units equal to the number of target variables (C_l and C_d)
model.add(Dense(units=Y_train.shape[1]))

# Compile the model
model.compile(optimizer='adam', loss='mse') # Using adam optimizer and mean squared error loss

# Reshape X_train for LSTM input (samples, timesteps, features)
# Assuming each row is a timestep
X_train_reshaped = X_train.values.reshape((X_train.shape[0], X_train.shape[1], 1))

# Fit the model
model.fit(X_train_reshaped, Y_train, epochs=20, batch_size=32) # You can adjust epochs and batch size

"""##Applying the model to make predictions"""

y_model_train_pred = model.predict(X_train)
y_model_test_pred = model.predict(X_test)
print(y_model_train_pred)

print(y_model_test_pred)

Y_train

Y_test

"""#Model performance"""

from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
model_train_mse=mean_squared_error(Y_train, y_model_train_pred)
model_train_r2= r2_score(Y_train, y_model_train_pred)

model_test_mse=mean_squared_error(Y_test, y_model_test_pred)
model_test_r2= r2_score(Y_test, y_model_test_pred)

model_results = pd.DataFrame (['LSTM', model_train_mse, model_train_r2, model_test_mse,model_test_r2]).transpose()
model_results

"""##Data Visualisation"""

import matplotlib.pyplot as plt
import numpy as np

fig, axs = plt.subplots(1, 2, figsize=(16, 6))  # 1 row, 2 columns

# Plot for C_l
axs[0].scatter(x=Y_train['C_l'], y=y_model_train_pred[:, 0], alpha=0.5)
z_cl = np.polyfit(Y_train['C_l'], y_model_train_pred[:, 0], 1)
p_cl = np.poly1d(z_cl)
axs[0].plot(Y_train['C_l'], p_cl(Y_train['C_l']), '#F8766D')
axs[0].set_xlabel('Experimental C_l')
axs[0].set_ylabel('Predicted C_l')
axs[0].set_title('LSTM Model Performance for C_l')
axs[0].grid(True)

# Plot for C_d
axs[1].scatter(x=Y_train['C_d'], y=y_model_train_pred[:, 1], alpha=0.5)
z_cd = np.polyfit(Y_train['C_d'], y_model_train_pred[:, 1], 1)
p_cd = np.poly1d(z_cd)
axs[1].plot(Y_train['C_d'], p_cd(Y_train['C_d']), '#F8766D')
axs[1].set_xlabel('Experimental C_d')
axs[1].set_ylabel('Predicted C_d')
axs[1].set_title('LSTM Model Performance for C_d')
axs[1].grid(True)

plt.tight_layout()
plt.show()